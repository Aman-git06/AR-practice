<!DOCTYPE html>
<html>
<head>
    <title>Marker-based AR with Media Switching & Zoom</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        /* Keep existing arrow styles */
        #arrows {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .arrow-btn {
            font-size: 24px;
            margin: 0 15px;
            padding: 5px 15px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        .arrow-btn:hover {
            background: #0056b3;
        }
        
        .media-content {
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">
    <!-- Camera Permission UI -->
    <div id="permission-ui" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; text-align: center; z-index: 9999;">
        <h2>Camera Permission Required</h2>
        <p>This AR experience needs access to your camera.</p>
        <button onclick="requestCamera()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Allow Camera Access</button>
    </div>

    <!-- AR Scene -->
    <a-scene 
        embedded 
        arjs="sourceType: webcam; 
              debugUIEnabled: false; 
              detectionMode: mono_and_matrix; 
              matrixCodeType: 3x3;
              sourceWidth: 1280;
              sourceHeight: 960;
              displayWidth: 1280;
              displayHeight: 960;"
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true;"
        inspector="url: https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js">
        
        <a-marker preset="hiro" id="marker" smooth="true" smoothCount="5" smoothTolerance="0.01" smoothThreshold="5">
            <!-- Media will be inserted here dynamically -->
        </a-marker>
        <a-entity camera></a-entity>
    </a-scene>

    <!-- Keep existing arrows and instructions structure -->
    <!-- ... -->
      <!-- Model Switching Arrows -->
    <div id="arrows">
        <button class="arrow-btn" id="leftArrow">←</button>
        <button class="arrow-btn" id="rightArrow">→</button>
    </div>

    <!-- Instructions -->
    <div style="position: fixed; top: 20px; left: 20px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 5px;">
        <h3>Instructions:</h3>
        <p>1. Print the Hiro marker from <a href="https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/hiro.png" target="_blank">here</a></p>
        <p>2. Point your camera at the marker</p>
        <p>3. Use arrows to switch models</p>
    </div>


    <script>
        // Camera permission handling
        const permissionUI = document.getElementById('permission-ui');
        
        async function requestCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                permissionUI.style.display = 'none';
                stream.getTracks().forEach(track => track.stop()); // Stop the test stream
            } catch (error) {
                console.error('Camera permission denied:', error);
                alert('Camera access is required for AR functionality. Please allow camera access and reload the page.');
            }
        }

        // Check if running on HTTPS
        if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
            alert('AR.js requires HTTPS to access the camera. Please serve this page over HTTPS.');
        }

        document.addEventListener('DOMContentLoaded', () => {
            const marker = document.querySelector('a-marker');
            const arrows = document.getElementById('arrows');
            
            // Define available media
            const media = [
                {
                    type: 'image',
                    src: 'https://upload.wikimedia.org/wikipedia/commons/6/6b/Picture_icon_BLACK.svg',
                    width: 1,
                    height: 1
                },
                {
                    type: 'video',
                    src: 'https://upload.wikimedia.org/wikipedia/commons/transcoded/4/4d/Wikipedia_Edit_2014.webm/Wikipedia_Edit_2014.webm.720p.vp9.webm',
                    width: 1.78,
                    height: 1
                },
                {
                    type: 'image',
                    src: 'https://cdn.aframe.io/360-image-gallery-boilerplate/img/city.jpg',
                    width: 1.5,
                    height: 1
                }
            ];
            
            let currentMediaIndex = 0;
            let isPinching = false;
            let initialDistance = null;
            let currentScale = 1;
            const minScale = 0.5;
            const maxScale = 3;

            // Add pinch-zoom functionality
            function handleTouchStart(e) {
                if (e.touches.length === 2) {
                    isPinching = true;
                    initialDistance = getDistanceBetweenTouches(e.touches);
                    const mediaEntity = document.querySelector('.media-content');
                    currentScale = mediaEntity.getAttribute('scale').x;
                }
            }

            function handleTouchMove(e) {
                if (!isPinching || e.touches.length !== 2) return;
                
                e.preventDefault();
                const mediaEntity = document.querySelector('.media-content');
                const newDistance = getDistanceBetweenTouches(e.touches);
                const scaleFactor = newDistance / initialDistance;
                
                let newScale = currentScale * scaleFactor;
                newScale = Math.max(minScale, Math.min(maxScale, newScale));
                
                mediaEntity.setAttribute('scale', `${newScale} ${newScale} ${newScale}`);
            }

            function handleTouchEnd() {
                isPinching = false;
                initialDistance = null;
            }

            function getDistanceBetweenTouches(touches) {
                const [t1, t2] = touches;
                return Math.hypot(
                    t2.clientX - t1.clientX,
                    t2.clientY - t1.clientY
                );
            }

            // Modified updateMedia function with touch events
            function updateMedia() {
                // Clear previous media
                while (marker.firstChild) {
                    marker.removeChild(marker.firstChild);
                }

                const mediaItem = media[currentMediaIndex];
                let entity;

                if (mediaItem.type === 'image') {
                    entity = document.createElement('a-image');
                    entity.setAttribute('src', mediaItem.src);
                } else if (mediaItem.type === 'video') {
                    entity = document.createElement('a-video');
                    entity.setAttribute('src', mediaItem.src);
                    entity.setAttribute('autoplay', 'true');
                    entity.setAttribute('loop', 'true');
                }

                // Common attributes
                entity.setAttribute('width', mediaItem.width);
                entity.setAttribute('height', mediaItem.height);
                entity.setAttribute('position', '0 0.5 0');
                entity.setAttribute('rotation', '-90 0 0');
                entity.setAttribute('scale', '1 1 1');
                entity.setAttribute('class', 'media-content');

                // Add touch event listeners
                entity.addEventListener('touchstart', handleTouchStart);
                entity.addEventListener('touchmove', handleTouchMove);
                entity.addEventListener('touchend', handleTouchEnd);
                entity.addEventListener('touchcancel', handleTouchEnd);

                marker.appendChild(entity);
            }

            // Keep existing marker detection and arrow handlers
            document.getElementById('leftArrow').addEventListener('click', () => {
                currentMediaIndex = (currentMediaIndex - 1 + media.length) % media.length;
                updateMedia();
            });

            document.getElementById('rightArrow').addEventListener('click', () => {
                currentMediaIndex = (currentMediaIndex + 1) % media.length;
                updateMedia();
            });

            // Initial media load
            updateMedia();
        });

        // Add marker detection feedback
        const marker = document.querySelector('a-marker');
        marker.addEventListener('markerFound', () => {
            console.log('Marker detected');
            document.getElementById('arrows').style.display = 'block';
        });

        marker.addEventListener('markerLost', () => {
            console.log('Marker lost');
            document.getElementById('arrows').style.display = 'none';
        });
    </script>
</body>
</html>
