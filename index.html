<!DOCTYPE html>
<html>
<head>
    <title>AR Media Viewer with Zoom</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        #arrows {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .arrow-btn {
            font-size: 24px;
            margin: 0 15px;
            padding: 5px 15px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        .arrow-btn:hover {
            background: #0056b3;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">
    <a-scene embedded arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3;">
        <a-marker preset="hiro" id="marker">
            <!-- Media will be inserted here dynamically -->
        </a-marker>
        <a-entity camera></a-entity>
    </a-scene>

    <div id="arrows">
        <button class="arrow-btn" id="leftArrow">←</button>
        <button class="arrow-btn" id="rightArrow">→</button>
    </div>

    <div style="position: fixed; top: 20px; left: 20px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 5px;">
        <h3>Instructions:</h3>
        <p>1. Use Hiro marker for tracking</p>
        <p>2. Use arrows to switch media</p>
        <p>3. Pinch with two fingers to zoom</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const marker = document.querySelector('a-marker');
            const arrows = document.getElementById('arrows');
            
            // Media configuration
            const media = [
                {
                    type: 'image',
                    src: 'https://upload.wikimedia.org/wikipedia/commons/6/6b/Picture_icon_BLACK.svg',
                    width: 1,
                    height: 1
                },
                {
                    type: 'video',
                    src: 'https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/videos/sintel.mp4',
                    width: 1.78,
                    height: 1
                },
                {
                    type: 'image',
                    src: 'https://upload.wikimedia.org/wikipedia/commons/3/3f/Fronalpstock_big.jpg',
                    width: 1.5,
                    height: 1
                }
            ];
            
            let currentMediaIndex = 0;
            let currentMediaEntity = null;
            let isPinching = false;
            let initialDistance = 0;
            let initialScale = { x: 1, y: 1 };

            // Touch event handlers for pinch-to-zoom
            function handleTouchStart(e) {
                if (e.touches.length === 2 && currentMediaEntity) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    initialDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    const scale = currentMediaEntity.getAttribute('scale');
                    initialScale = { x: scale.x, y: scale.y };
                    isPinching = true;
                }
            }

            function handleTouchMove(e) {
                if (isPinching && e.touches.length === 2 && currentMediaEntity) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    const scaleFactor = currentDistance / initialDistance;
                    
                    const newScale = {
                        x: initialScale.x * scaleFactor,
                        y: initialScale.y * scaleFactor,
                        z: 1
                    };
                    currentMediaEntity.setAttribute('scale', newScale);
                }
            }

            function handleTouchEnd() {
                isPinching = false;
            }

            // Add touch event listeners
            window.addEventListener('touchstart', handleTouchStart);
            window.addEventListener('touchmove', handleTouchMove);
            window.addEventListener('touchend', handleTouchEnd);

            // Media management
            function createMediaEntity(mediaItem) {
                let entity;
                if (mediaItem.type === 'image') {
                    entity = document.createElement('a-image');
                    entity.setAttribute('src', mediaItem.src);
                } else if (mediaItem.type === 'video') {
                    entity = document.createElement('a-video');
                    entity.setAttribute('src', mediaItem.src);
                    entity.setAttribute('autoplay', 'true');
                    entity.setAttribute('loop', 'true');
                }

                entity.setAttribute('width', mediaItem.width);
                entity.setAttribute('height', mediaItem.height);
                entity.setAttribute('position', '0 0.5 0');
                entity.setAttribute('rotation', '-90 0 0');
                entity.setAttribute('scale', '1 1 1');
                return entity;
            }

            function updateMedia() {
                // Clear previous media
                while (marker.firstChild) {
                    marker.removeChild(marker.firstChild);
                }

                const mediaItem = media[currentMediaIndex];
                currentMediaEntity = createMediaEntity(mediaItem);
                marker.appendChild(currentMediaEntity);
            }

            // Event listeners for marker detection
            marker.addEventListener('markerFound', () => arrows.style.display = 'block');
            marker.addEventListener('markerLost', () => arrows.style.display = 'none');

            // Arrow controls
            document.getElementById('leftArrow').addEventListener('click', () => {
                currentMediaIndex = (currentMediaIndex - 1 + media.length) % media.length;
                updateMedia();
            });

            document.getElementById('rightArrow').addEventListener('click', () => {
                currentMediaIndex = (currentMediaIndex + 1) % media.length;
                updateMedia();
            });

            // Initial setup
            updateMedia();
        });
    </script>
</body>
</html>
